# `hydrateRoot` – React DOM Client API

> Converted to Markdown from the official React docs page for `react-dom/client/hydrateRoot`.  
> Source (accessed 2025‑08‑20): https://react.dev/reference/react-dom/client/hydrateRoot

---

`hydrateRoot` lets you attach React to HTML that was already rendered on the server (via `react-dom/server`) and make it interactive on the client.

```js
import { hydrateRoot } from 'react-dom/client';

const root = hydrateRoot(domNode, reactNode, options?);
```

## Reference

### `hydrateRoot(domNode, reactNode, options?)`

Attach React to existing server-rendered HTML inside a browser DOM node.

```js
import { hydrateRoot } from "react-dom/client";

const domNode = document.getElementById("root");
const root = hydrateRoot(domNode, <App />);
```

React takes control of the DOM subtree inside `domNode`. In most apps there will be a single call to `hydrateRoot` at startup (your framework may do this for you).

#### Parameters

- **`domNode`**: The root DOM element that received server-rendered HTML.
- **`reactNode`**: The React tree used to produce that HTML (usually `<App />`).
- **`options` (optional)**:
  - `onCaughtError(error, errorInfo)` – invoked when an error is caught by an Error Boundary. `errorInfo` includes `componentStack`.
  - `onUncaughtError(error, errorInfo)` – invoked for uncaught errors outside Error Boundaries.
  - `onRecoverableError(error, errorInfo)` – invoked when React recovers from certain errors.
  - `identifierPrefix` – prefix for IDs generated by `useId`; must match the prefix used on the server when multiple roots exist on a page.

#### Returns

An object with two methods: **`render`** and **`unmount`**.

#### Caveats

- The client render **must match** the server HTML. Treat mismatches as bugs.
- In development, React warns about hydration mismatches; patching is not guaranteed.
- If you don’t have server-rendered HTML, **don’t use** `hydrateRoot`; use `createRoot()`.

---

### `root.render(reactNode)`

Update the content of a hydrated root.

```js
root.render(<App />);
```

- **Parameters**: `reactNode` – a React node (JSX, an element created with `createElement`, string, number, `null`, or `undefined`).
- **Returns**: `undefined`.
- **Caveat**: Calling `root.render` **before hydration finishes** will discard the server HTML and fall back to client rendering for the whole root.

---

### `root.unmount()`

Destroy the React tree inside the root and detach React from the DOM node.

```js
root.unmount();
```

- Useful when external code may remove the root DOM node (e.g., tab panels).
- **Returns**: `undefined`.
- **Caveats**:
  - Unmounting removes all event handlers/state in the tree.
  - After `unmount`, you **cannot** call `root.render` again on that root.

---

## Usage

### Hydrating server-rendered HTML

```js
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";

hydrateRoot(document.getElementById("root"), <App />);
```

From this point on, React manages the DOM. To update UI, change component **state** instead of calling `root.render` repeatedly.

**Pitfall:** The React tree passed to `hydrateRoot` must render the **same output** as on the server. Common causes of mismatches include:

- Extra whitespace/newlines around the server HTML inside the root.
- Conditional branches like `if (typeof window !== 'undefined')` in render paths.
- Using browser-only APIs (e.g., `window.matchMedia`) during render.
- Rendering different data on server vs client.

React can recover from some issues, but mismatches can degrade performance or bind events incorrectly.

---

### Hydrating an entire document

You can render an entire HTML document with JSX (including `<html>`):

```jsx
function App() {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/styles.css" />
        <title>My app</title>
      </head>
      <body>
        <Router />
      </body>
    </html>
  );
}
```

Hydrate by passing the global `document` as the first argument:

```js
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";

hydrateRoot(document, <App />);
```

---

### Suppressing unavoidable hydration mismatch warnings

If a small piece of content is **intentionally** different (e.g., timestamps), you can silence the warning **one level deep**:

```jsx
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

Avoid overusing this escape hatch—React won’t patch mismatched text for you.

---

### Handling different client vs server content (two-pass rendering)

When some UI must differ on the client, render identical content initially and then update after hydration:

```jsx
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return <h1>{isClient ? "Is Client" : "Is Server"}</h1>;
}
```

**Note:** This makes hydration slower because components render twice and may feel jarring if JS loads late.

---

### Updating a hydrated root component

You usually won’t call `root.render` after hydration, but if you do and the tree structure matches the server output, React **preserves state**:

```js
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";

const root = hydrateRoot(document.getElementById("root"), <App counter={0} />);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

Prefer updating component state inside the tree instead of repeatedly calling `root.render`.

---

### Error logging in production

Provide custom error handlers through the `hydrateRoot` options to report errors in production:

```js
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");
const root = hydrateRoot(container, <App />, {
  onCaughtError: (error, errorInfo) => {
    if (error.message !== "Known error") {
      reportCaughtError({
        error,
        componentStack: errorInfo.componentStack,
      });
    }
  },
});
```

Or wire multiple handlers:

```js
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
  // In development, prefer React's default overlays/handlers.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
```

---

## Troubleshooting

### Error: “You passed a second argument to `root.render`”

Don’t pass `hydrateRoot` options to `root.render`:

```js
// ❌ Wrong – root.render only accepts one argument
root.render(<App />, { onUncaughtError });
```

Pass options to `hydrateRoot` instead:

```js
// ✅ Correct
const root = hydrateRoot(container, <App />, { onUncaughtError });
```

---

© Meta Platforms, Inc. (React docs). Logos and artwork belong to their respective owners.
